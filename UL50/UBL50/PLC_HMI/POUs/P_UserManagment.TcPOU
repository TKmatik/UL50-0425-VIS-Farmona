<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="P_UserManagment" Id="{3d68040b-df6d-465d-b51b-336879341412}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P_UserManagment
VAR	
	user_log				:BOOL 				:= GVL_USER.user_try_to_log;           	//użytkownik wywołał okno logowania
	user_accept				:BOOL 				:= GVL_USER.user_accept_to_log_in;     	//użytkownik zaakceptował hasło
	outside_login_accept	:BOOL				:= gvl_user.outside_accept_login;		//przekazanie potwierdzenia procesu logowania
	user_login_error		:BOOL 				:= GVL_USER.no_user_found;				//brak dopasowanego użytkownika
	user_log_succes			:BOOL 				:= GVL_USER.user_succesed_log;			//zalogowano z powodzeniem
	i,j,z					:INT;														//zmienne dla warunków
	bprzypisanie			:BOOL;
	btest					:BOOL:=FALSE;
	k						:INT;
	userExists				:BOOL;														//zmienne dla programu
	outside_login_pool		:STRING(255)		:= gvl_user.outside_login_pool;												//przekazanie loginu do wizualizacji
	user_password			:STRING(255) 		:= GVL_USER.putted_user_password;		//wprowadzone użytkownikiem hasło
	b_new_users				:BOOL;									
	delayTimer: TON;  // Timer do opóźnienia o 500 ms					//nowe wgranie użytkowników
	allowedGroups : ARRAY[1..5] OF STRING(80) := ['Admin', 'Mechanik', 'Operator', 'Technolog', 'Serwis'];
	allowedGroupsNumber	:ARRAY[1..5] OF UINT:=[1,2,3,4,5];
	validGroup    : BOOL;  // Zmienna do walidacji grupy
    uniqueUser    : BOOL;  // Zmienna sprawdzająca unikalność hasła
    freeSlot      : BOOL;  // Zmienna wskazująca wolne miejsce na nowego użytkownika
	bwait	:BOOL :=gvl_user.bwait; //ekran oczekiwania na plc
	bClear	:BOOL:=FALSE;
	iClearArrayNr :INT;
	
	actual_user : WSTRING(255);
	

	new_user				:BOOL := GVL_USER.new_user;			//inicjalizacja dodania nowego użytkownika
	new_user_accept			:BOOL := GVL_USER.new_user_accept;			//akceptacja dodania użytkownika z ekranu
	new_user_added			:BOOL := GVL_USER.new_user_added;			//udane dodanie użytkownika
	new_user_add_error		:BOOL := GVL_USER.new_user_add_error;			//nieudane dodawanie
	newautoLogOff			:STRING(80) := GVL_USER.newautoLogOff;			//czas do wylogowania
	newuserNameSurname 		:WSTRING(255)  := GVL_USER.newuserNameSurname;	//imię i nazwisko				
	newpassword				:STRING(255) := GVL_USER.newpassword;	//hasło
	newpasswordRFID			:STRING(255) := GVL_USER.newpasswordRFID;	//hasło rfid
	newpasswordQR			:STRING(255) := GVL_USER.newpasswordQR;	//hasło qr
	newuserGroup			:STRING(80) := GVL_USER.newuserGroup;		//grupa użytkowników
	newuserLogoffbetween 	:STRING(80);
	
	edit_user						:BOOL := GVL_USER.edit_user;	//inicjalizacja edycji parametrów użytkownika
	edit_user_accept				:BOOL := GVL_USER.edit_user_accept;	//akceptacja wprowadzonych zmiennych z ekranu
	user_eddited					:BOOL := GVL_USER.user_eddited;	//odpowiedź z plc do hmi - udana edycja
	edit_user_qr_or_rfid_password	:BOOL := GVL_USER.edit_user_qr_or_rfid_password;	//edycja rfid lub qr dopisanego do użytkownika
	edit_user_error					:BOOL := GVL_USER.edit_user_error;			//odpowiedź z plc do hmi - nieudana edycja uzytkownika
	editautoLogOff					:STRING(80) := GVL_USER.editautoLogOff;			//czas do wylogowania użytkownika
	edituserNameSurname 			:WSTRING(255) := GVL_USER.edituserNameSurname ;	//imię i nazwisko
	editpassword					:STRING(255) := GVL_USER.editpassword;	//hasło
	editpasswordRFID				:STRING(255) := GVL_USER.editpasswordRFID;	//hasło rfid
	editpasswordQR					:STRING(255) := GVL_USER.editpasswordQR;	//hasło qr
	edituserGroup					:STRING(80) := GVL_USER.edituserGroup;	//grupa użytkowników
	edituserLogoffbetween 	:STRING(80);

	userExists_2			:BOOL;
	userExists_3			:BOOL;
	
	bFirstCycle				:BOOL := FALSE;
	
	iValueForCheck			:INT;
	logowanie_krok	:INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
bFirstCycle:=TRUE; //Symulacja 1 cyklu sterownika

IF bClear THEN 
    // Sprawdzamy, czy numer wiersza mieści się w zakresie tablicy
    IF (iClearArrayNr >= 1) AND (iClearArrayNr <= 100) THEN
        // Czyszczenie wybranego wiersza tablicy
        GVL_USER.user_array[iClearArrayNr].userID := 0;
        GVL_USER.user_array[iClearArrayNr].domain := '';
        GVL_USER.user_array[iClearArrayNr].enabled := FALSE;
        GVL_USER.user_array[iClearArrayNr].userLogin := '';
        GVL_USER.user_array[iClearArrayNr].userNameSurname := "";  // WSTRING wymaga również pustego ciągu znaków
        GVL_USER.user_array[iClearArrayNr].password := '';
        GVL_USER.user_array[iClearArrayNr].passwordRFID := 'tup';
        GVL_USER.user_array[iClearArrayNr].passwordQR := 'tup';
        GVL_USER.user_array[iClearArrayNr].userGroup := '';
        GVL_USER.user_array[iClearArrayNr].autoLogOff := '';
        GVL_USER.user_array[iClearArrayNr].locale := '';
        GVL_USER.user_array[iClearArrayNr].timeFormatlocale := '';
        GVL_USER.user_array[iClearArrayNr].timeZone := '';
        GVL_USER.user_array[iClearArrayNr].signedPassword := '';
    END_IF

    // Resetowanie flagi bClear po wykonaniu czyszczenia
    bClear := FALSE;
END_IF

// Proces logowania użytkownika GVL_USER.user_try_to_log AND
IF  GVL_USER.user_accept_to_log_in THEN
    GVL_USER.user_succesed_log := FALSE;
    GVL_USER.no_user_found := TRUE;
    gvl_user.bwait := TRUE;
	iValueForCheck:=1;    
	userExists_3 := FALSE;	
    FOR i := 1 TO 100 DO
		
        IF GVL_USER.user_array[i].password = GVL_USER.putted_user_password OR 
           (GVL_USER.user_array[i].passwordRFID = GVL_USER.putted_user_password) OR 
           (GVL_USER.user_array[i].passwordQR = GVL_USER.putted_user_password) THEN
		   
            GVL_USER.currentUser := i;
            userExists_3 := TRUE;
			iValueForCheck:=2;
            EXIT;
			
        END_IF
		
    END_FOR

    IF NOT userExists_3 THEN
		
        GVL_USER.no_user_found := TRUE;
        gvl_user.bwait := FALSE;
		userExists_3 := FALSE;
		iValueForCheck:=3;
		GVL_USER.currentUser := 6;
		gvl_user.currentUserName :="Niezalogowany Użytkownik";
		gvl_user.currentUserGroup :='Niezalogowany';
		gvl_user.currentUserGroupNumber :=0; //
        GVL_USER.user_succesed_log := TRUE;  // Potwierdzenie, że wylogowanie i logowanie zakończyły się sukcesem
        GVL_USER.logout := FALSE;  // Resetowanie sygnału wylogowania
		GVL_USER.putted_user_password:='';
    ELSE

        FOR i := 1 TO 100 DO
            // Sprawdzenie, czy użytkownik jest aktywny
            IF GVL_USER.user_array[i].enabled THEN
                // Sprawdzenie, czy wprowadzone hasło odpowiada loginowi lub RFID/QR
                GVL_USER.no_user_found := FALSE;
				iValueForCheck:=4;
                IF (GVL_USER.user_array[i].password = GVL_USER.putted_user_password) OR
                   (GVL_USER.user_array[i].passwordRFID = GVL_USER.putted_user_password) OR
                   (GVL_USER.user_array[i].passwordQR = GVL_USER.putted_user_password) THEN
                   //delayTimer(IN := TRUE, PT := T#1S);
				   iValueForCheck:=5;
                    // Jeśli wprowadzony kod to RFID lub QR, zastąp go przypisanym hasłem
                    IF GVL_USER.user_array[i].passwordRFID = GVL_USER.putted_user_password THEN
                        GVL_USER.putted_user_password := GVL_USER.user_array[i].password;
						iValueForCheck:=6;
                    	ELSIF GVL_USER.user_array[i].passwordQR = GVL_USER.putted_user_password THEN
                        	GVL_USER.putted_user_password := GVL_USER.user_array[i].password;
							iValueForCheck:=6;
                    END_IF

                 // Sprawdzanie grupy użytkownika i przypisanie odpowiedniej wartości
                 	IF GVL_USER.user_array[i].userGroup = 'Admin' THEN
						iValueForCheck:=7;
                        gvl_user.password_to_log_in := GVL_USER.user_array[i].signedPassword;
                    	ELSIF GVL_USER.user_array[i].userGroup = 'Operator' THEN
                        	gvl_user.password_to_log_in := GVL_USER.user_array[i].signedPassword;
                    	ELSIF GVL_USER.user_array[i].userGroup = 'Serwis' THEN
                        	gvl_user.password_to_log_in := GVL_USER.user_array[i].signedPassword;
                    	ELSIF GVL_USER.user_array[i].userGroup = 'Technolog' THEN
                       		gvl_user.password_to_log_in := GVL_USER.user_array[i].signedPassword;
                    	ELSIF GVL_USER.user_array[i].userGroup = 'Mechanik' THEN
                        	gvl_user.password_to_log_in := GVL_USER.user_array[i].signedPassword;
                    END_IF
                    //IF delayTimer.Q THEN
                		//delayTimer(IN := FALSE);
						iValueForCheck:=8;
						gvl_user.currentUserName := GVL_USER.user_array[i].userNameSurname;
						gvl_user.currentUserGroup := GVL_USER.user_array[i].userGroup;
						gvl_user.currentUserGroupNumber := GVL_USER.user_array[i].userGropuNumber;
                    	GVL_USER.user_succesed_log := TRUE;
                    	GVL_USER.no_user_found := FALSE;                   
                    	gvl_user.bwait := FALSE;
                    	GVL_USER.user_try_to_log := FALSE;
                    	GVL_USER.user_accept_to_log_in := FALSE;
                    // Zerowanie zmiennych po udanym logowaniu
					//gvl_user.outside_accept_login := TRUE;  // Informacja dla wizualizacji
                    //GVL_USER.putted_user_password := '';   // Wyczyszczenie wprowadzonego hasła
                    // Wyczyszczenie hasła do logowania
					//gvl_user.password_to_log_in := '';
					//userExists_3 := FALSE;
					END_IF					
                END_IF
            
        END_FOR
		
        // Jeżeli pętla się zakończy i nie znaleziono użytkownika
        IF NOT GVL_USER.user_succesed_log THEN
            GVL_USER.no_user_found := TRUE; // Ustaw błąd logowania
            gvl_user.bwait := FALSE;
			userExists_3 := FALSE;
			GVL_USER.user_succesed_log := FALSE;
			GVL_USER.putted_user_password:='';
			iValueForCheck:=9;
        END_IF
    END_IF
	GVL_USER.user_succesed_log := FALSE;
	userExists_3:=FALSE;
END_IF
(*IF GVL_USER.user_accept_to_log_in THEN
    logowanie_krok := 1;
END_IF

CASE logowanie_krok OF
    // Krok 0: Stan początkowy
    0:  GVL_USER.no_user_found := FALSE;
        GVL_USER.user_succesed_log := FALSE;
        gvl_user.bwait := FALSE;
        userExists_3 := FALSE;
        iValueForCheck := 0;
    // Krok 1: Inicjalizacja procesu logowania
    1:	logowanie_krok := 2;
        GVL_USER.user_succesed_log := FALSE;
        gvl_user.bwait := TRUE;
        iValueForCheck := 1;
        userExists_3 := FALSE;
    // Krok 2: Szukanie użytkownika na podstawie hasła, RFID lub QR kodu
    2:  FOR i := 1 TO 100 DO
            IF (GVL_USER.user_array[i].password = GVL_USER.putted_user_password) OR 
               (GVL_USER.user_array[i].passwordRFID = GVL_USER.putted_user_password) OR 
               (GVL_USER.user_array[i].passwordQR = GVL_USER.putted_user_password) 
				THEN
                GVL_USER.currentUser := i;
                userExists_3 := TRUE;
				EXIT; // Znaleziono użytkownika, wyjście z pętli
            END_IF
        END_FOR
		
        // Przejdź do kroku 3, jeśli użytkownik nie istnieje
		IF GVL_USER.currentUser <=100 AND GVL_USER.currentUser >0 THEN
        	logowanie_krok := 4;
        		ELSE
            // Jeśli użytkownik istnieje, przejdź do kroku 4
            logowanie_krok := 3;
        	END_IF
    // Krok 3: Obsługa przypadku, gdy użytkownik nie został znaleziony
    3:
        GVL_USER.no_user_found := TRUE;
        gvl_user.bwait := FALSE;
        userExists_3 := FALSE;
        iValueForCheck := 3;
        GVL_USER.putted_user_password := '';
        // Resetowanie zmiennych i powrót do stanu wyjściowego
        logowanie_krok := 0;
    // Krok 4: Sprawdzenie, czy użytkownik jest aktywny
    4:
        IF GVL_USER.user_array[GVL_USER.currentUser].enabled THEN
            GVL_USER.no_user_found := FALSE;
            iValueForCheck := 4;

            // Jeśli wprowadzony kod to RFID lub QR, zastąp go hasłem
            IF GVL_USER.user_array[GVL_USER.currentUser].passwordRFID = GVL_USER.putted_user_password THEN
                GVL_USER.putted_user_password := GVL_USER.user_array[GVL_USER.currentUser].password;
            ELSIF GVL_USER.user_array[GVL_USER.currentUser].passwordQR = GVL_USER.putted_user_password THEN
                GVL_USER.putted_user_password := GVL_USER.user_array[GVL_USER.currentUser].password;
            END_IF

            // Przypisanie hasła w zależności od grupy użytkownika
            CASE GVL_USER.user_array[GVL_USER.currentUser].userGropuNumber OF
                1: gvl_user.password_to_log_in := GVL_USER.user_array[GVL_USER.currentUser].signedPassword;
                2: gvl_user.password_to_log_in := GVL_USER.user_array[GVL_USER.currentUser].signedPassword;
                3: gvl_user.password_to_log_in := GVL_USER.user_array[GVL_USER.currentUser].signedPassword;
                4: gvl_user.password_to_log_in := GVL_USER.user_array[GVL_USER.currentUser].signedPassword;
                5: gvl_user.password_to_log_in := GVL_USER.user_array[GVL_USER.currentUser].signedPassword;
            END_CASE;

            iValueForCheck := 6;

            // Przejdź do kroku 5
            logowanie_krok := 5;
        ELSE
            // Jeżeli użytkownik nie został znaleziony, przejdź do kroku 3
            logowanie_krok := 3;
        END_IF

    // Krok 5: Zakończenie procesu logowania
    5:
        gvl_user.currentUserName := GVL_USER.user_array[GVL_USER.currentUser].userNameSurname;
        gvl_user.currentUserGroup := GVL_USER.user_array[GVL_USER.currentUser].userGroup;
        gvl_user.currentUserGroupNumber := GVL_USER.user_array[GVL_USER.currentUser].userGropuNumber;

        GVL_USER.user_succesed_log := TRUE;
        GVL_USER.no_user_found := FALSE;
        gvl_user.bwait := FALSE;
        GVL_USER.user_try_to_log := FALSE;
        GVL_USER.user_accept_to_log_in := FALSE;

        // Zerowanie zmiennych po udanym logowaniu
        GVL_USER.putted_user_password := '';
        gvl_user.password_to_log_in := '';
        userExists_3 := FALSE;
        iValueForCheck := 7;

        // Resetowanie zmiennych i powrót do stanu wyjściowego
        logowanie_krok := 0;

END_CASE;
*)


// Dodawanie nowego użytkownika
IF GVL_USER.new_user AND GVL_USER.new_user_accept THEN
    GVL_USER.new_user_added := FALSE;
    GVL_USER.new_user_add_error := TRUE;
	gvl_user.bwait := TRUE;
    validGroup := FALSE;  // Na początku zakładamy, że grupa nie jest poprawna
    uniqueUser := TRUE;   // Na początku zakładamy, że hasło jest unikalne
    freeSlot := FALSE;    // Na początku zakładamy, że nie ma wolnego miejsca
    
    // Sprawdzanie, czy wybrana grupa jest jedną z dozwolonych GVL_USER.newuserGroup = allowedGroups[j] 
    FOR j := 1 TO 5 DO
        IF GVL_USER.newuserGroupNumber = allowedGroupsNumber[j]	THEN
            	validGroup := TRUE;  // Jeśli grupa jest dozwolona, ustawiamy na TRUE
        END_IF
    END_FOR

    // Jeśli grupa nie jest poprawna, przerywamy proces dodawania użytkownika
    IF NOT validGroup THEN
        GVL_USER.new_user_add_error := TRUE;
    ELSE
        // Sprawdzanie, czy hasło nie jest już przypisane do innego użytkownika
        FOR i := 7 TO 100 DO
            IF GVL_USER.user_array[i].enabled AND 
               ((GVL_USER.user_array[i].password = GVL_USER.newpassword) OR 
                (GVL_USER.user_array[i].passwordRFID = GVL_USER.newpasswordRFID) OR 
                (GVL_USER.user_array[i].passwordQR = GVL_USER.newpasswordQR)) THEN
                uniqueUser := FALSE;  // Jeśli hasło, RFID lub QR istnieje, ustawiamy na FALSE
            END_IF
        END_FOR

        // Jeśli hasło jest unikalne, szukamy wolnego miejsca w tablicy
        IF uniqueUser THEN
            FOR i := 6 TO 100 DO
                IF NOT GVL_USER.user_array[i].enabled THEN
                    // Przypisanie danych nowego użytkownika
                    GVL_USER.user_array[i].userID := i;
                    GVL_USER.user_array[i].userLogin := GVL_USER.newpassword; // Używamy loginu z hasła
                    GVL_USER.user_array[i].userNameSurname := GVL_USER.newuserNameSurname;
                    GVL_USER.user_array[i].password := GVL_USER.newpassword;

                    // Sprawdzanie, czy pole RFID jest puste - jeśli tak, zapisujemy "tup"
                    IF GVL_USER.newpasswordRFID = '' THEN
                        GVL_USER.user_array[i].passwordRFID := 'tup';
                    ELSE
                        GVL_USER.user_array[i].passwordRFID := GVL_USER.newpasswordRFID;
                    END_IF

                    // Sprawdzanie, czy pole QR jest puste - jeśli tak, zapisujemy "tup"
                    IF GVL_USER.newpasswordQR = '' THEN
                        GVL_USER.user_array[i].passwordQR := 'tup';
                    ELSE
                        GVL_USER.user_array[i].passwordQR := GVL_USER.newpasswordQR;
                    END_IF
                    newuserLogoffbetween:= CONCAT('PT',GVL_USER.newautoLogOff);
                    GVL_USER.user_array[i].userGroup := GVL_USER.newuserGroup;  // Grupa musi być poprawna
                    GVL_USER.user_array[i].autoLogOff := Concat(newuserLogoffbetween,'M');
                    GVL_USER.user_array[i].enabled := TRUE;
					gvl_user.user_array[i].locale:='client';
					gvl_user.user_array[i].timeFormatlocale:='project';
					gvl_user.user_array[i].timeZone:='project';
					gvl_user.user_array[i].domain:='TcHmiUserManagment';
					
					IF GVL_USER.newuserGroupNumber =1 THEN
                        GVL_USER.user_array[i].signedPassword := 'adm';
						GVL_USER.user_array[i].userGropuNumber :=1;
                    ELSIF GVL_USER.newuserGroupNumber =3 THEN
                        GVL_USER.user_array[i].signedPassword := 'opr';
						GVL_USER.user_array[i].userGropuNumber :=3;
                    ELSIF GVL_USER.newuserGroupNumber =5 THEN
                        GVL_USER.user_array[i].signedPassword := 'ser';
						GVL_USER.user_array[i].userGropuNumber :=4;
                    ELSIF GVL_USER.newuserGroupNumber =4 THEN
                        GVL_USER.user_array[i].signedPassword := 'tech';
						GVL_USER.user_array[i].userGropuNumber :=5;
                    ELSIF GVL_USER.newuserGroupNumber =2 THEN
                        GVL_USER.user_array[i].signedPassword := 'mech';
						GVL_USER.user_array[i].userGropuNumber :=2;
                    END_IF
                    
                    // Potwierdzenie dodania nowego użytkownika
                    GVL_USER.new_user_added := TRUE;
                    GVL_USER.new_user_add_error := FALSE;
                    freeSlot := TRUE;  // Znalazło się wolne miejsce
					gvl_user.bwait := FALSE;
                    EXIT;  // Możemy zakończyć pętlę, bo użytkownik został dodany
                END_IF
            END_FOR
        ELSE
            // Hasło, RFID lub QR już istnieje - błąd dodawania użytkownika
            GVL_USER.new_user_add_error := TRUE;
			gvl_user.bwait := FALSE;
        END_IF
    END_IF

    // Jeśli nie znaleziono wolnego miejsca, ustawiamy błąd dodawania
    IF NOT freeSlot THEN
        GVL_USER.new_user_add_error := TRUE;
		gvl_user.bwait := FALSE;
    END_IF
	GVL_USER.new_user:=FALSE;
	validGroup:=FALSE;
	GVL_USER.user_succesed_log := FALSE;
END_IF

IF NOT GVL_USER.new_user THEN
	GVL_USER.new_user_accept:=FALSE;
	gvl_user.bwait := FALSE;
	validGroup:=FALSE;
	GVL_USER.newpasswordQR:='';
	GVL_USER.newpasswordRFID:='';
	newuserLogoffbetween:='';
END_IF



// Edycja istniejącego użytkownika
IF GVL_USER.edit_user AND GVL_USER.edit_user_accept THEN
    GVL_USER.user_eddited := FALSE;
    GVL_USER.edit_user_error := TRUE;
    validGroup := FALSE;  // Na początku zakładamy, że grupa nie jest poprawna
	gvl_user.bwait := TRUE;
    
    // Sprawdzanie, czy użytkownik o podanym imieniu i nazwisku istnieje
    userExists := FALSE;
    FOR i := 1 TO 100 DO
        IF GVL_USER.user_array[i].enabled AND 
           GVL_USER.user_array[i].userNameSurname = GVL_USER.actual_editted_user THEN
            GVL_USER.currentUser := i;
            userExists := TRUE;
            EXIT;  // Zatrzymujemy pętlę, gdy znajdziemy użytkownika
        END_IF
    END_FOR

    // Jeśli użytkownik nie istnieje, kończymy edycję
    IF NOT userExists THEN
        GVL_USER.edit_user_error := TRUE;
        gvl_user.bwait := FALSE;
    ELSE
        // Sprawdzanie, czy użytkownik do edycji jest aktywny
        IF GVL_USER.user_array[GVL_USER.currentUser].enabled THEN
            // Aktualizacja danych użytkownika	

            // Sprawdzanie, czy Imię i Nazwisko ma być zmienione
            IF GVL_USER.edituserNameSurname <> "" THEN
                GVL_USER.user_array[GVL_USER.currentUser].userNameSurname := GVL_USER.edituserNameSurname;
            END_IF
			
            // Sprawdzanie, czy hasło ma być zmienione
			IF GVL_USER.editpassword <> '' THEN
                GVL_USER.user_array[GVL_USER.currentUser].password := GVL_USER.editpassword;
            END_IF

            // Sprawdzanie, czy RFID ma być zmienione
            IF GVL_USER.editpasswordRFID <> '' THEN
                GVL_USER.user_array[GVL_USER.currentUser].passwordRFID := GVL_USER.editpasswordRFID;
            END_IF

            // Sprawdzanie, czy QR ma być zmienione
            IF GVL_USER.editpasswordQR <> '' THEN
                GVL_USER.user_array[GVL_USER.currentUser].passwordQR := GVL_USER.editpasswordQR;
            END_IF
			
			// Sprawdzanie, czy czas wylogowania ma być zmieniony
            IF GVL_USER.editautoLogOff <> '' THEN
				edituserLogoffbetween := CONCAT('PT', GVL_USER.editautoLogOff);
                GVL_USER.user_array[GVL_USER.currentUser].autoLogOff := CONCAT(edituserLogoffbetween, 'M');
            END_IF

            // Sprawdzanie, czy grupa ma być zmieniona
            IF GVL_USER.edituserGroupNumber <> 0 THEN
                // Sprawdzanie, czy wybrana grupa jest jedną z dozwolonych
                FOR j := 1 TO 5 DO
                    IF GVL_USER.edituserGroupNumber = allowedGroupsnumber[j] THEN
                        validGroup := TRUE;  // Jeśli grupa jest dozwolona, ustawiamy na TRUE
                        EXIT;  // Wychodzimy z pętli, bo znaleźliśmy poprawną grupę
                    END_IF
                END_FOR

                // Jeśli grupa nie jest poprawna, przerywamy proces edycji użytkownika
                IF NOT validGroup THEN
                    GVL_USER.edit_user_error := TRUE;
					gvl_user.bwait := FALSE;
					RETURN;  // Kończymy operację, gdy grupa jest nieprawidłowa
                ELSE
                    GVL_USER.user_array[GVL_USER.currentUser].userGroup := GVL_USER.edituserGroup;
                END_IF
            END_IF
            
            // Potwierdzenie edycji użytkownika
            GVL_USER.user_eddited := TRUE;
            GVL_USER.edit_user_error := FALSE;
			gvl_user.bwait := FALSE;
			GVL_USER.user_succesed_log := FALSE;
        END_IF
    END_IF
END_IF

IF NOT GVL_USER.edit_user THEN
	GVL_USER.edit_user_accept:=FALSE;
	gvl_user.bwait := FALSE;
END_IF


// Usuwanie użytkownika
IF GVL_USER.delete_user AND GVL_USER.delete_user_accept THEN
    GVL_USER.delete_user_error := TRUE;  // Zakładamy na początku, że operacja się nie uda
    GVL_USER.user_deleted_succes := FALSE;  // Zmienna sygnalizująca usunięcie użytkownika
    
    // Sprawdzanie, czy użytkownik o podanym imieniu i nazwisku istnieje
    userExists_2 := FALSE;
    FOR i := 1 TO 100 DO
        IF GVL_USER.user_array[i].enabled AND 
           GVL_USER.user_array[i].userNameSurname = GVL_USER.choosen_to_delete THEN
           
            // Użytkownik znaleziony, usuwamy go
            GVL_USER.user_array[i].userID := 0;
            GVL_USER.user_array[i].domain := '';
            GVL_USER.user_array[i].enabled := FALSE;
            GVL_USER.user_array[i].userLogin := '';
            GVL_USER.user_array[i].userNameSurname := "";
            GVL_USER.user_array[i].password := '';
			GVL_USER.user_array[i].signedPassword := '';
            GVL_USER.user_array[i].passwordRFID := '';
            GVL_USER.user_array[i].passwordQR := '';
            GVL_USER.user_array[i].userGroup := '';
			GVL_USER.user_array[i].userGropuNumber:=0;
            GVL_USER.user_array[i].autoLogOff := '';
            GVL_USER.user_array[i].locale := '';
            GVL_USER.user_array[i].timeFormatlocale := '';
            GVL_USER.user_array[i].timeZone := '';
            
            userExists_2 := TRUE;
            GVL_USER.delete_user_error := FALSE;  // Operacja usunięcia powiodła się
            GVL_USER.user_deleted_succes := TRUE;  // Potwierdzenie, że użytkownik został usunięty
            EXIT;  // Zatrzymanie pętli po znalezieniu i usunięciu użytkownika
        END_IF
    END_FOR
    
    // Jeśli użytkownika nie znaleziono, ustaw błąd
    IF NOT userExists_2 THEN
        GVL_USER.delete_user_error := TRUE;  // Nie znaleziono użytkownika
        GVL_USER.user_deleted_succes := FALSE;
    END_IF
	gvl_user.choosen_to_delete:="";
	gvl_user.delete_user_accept:=FALSE;
	userExists_2:=FALSE;
	GVL_USER.user_succesed_log := FALSE;
	GVL_USER.user_deleted_succes := FALSE;
END_IF


// Proces wylogowania użytkownika
IF GVL_USER.logout THEN
    // Czyszczenie danych aktualnie zalogowanego użytkownika
    IF GVL_USER.currentUser >= 1 AND GVL_USER.currentUser <= 100 THEN
       
        // Ustawienie użytkownika "niezalogowany" z wiersza pod indeksem 6
        GVL_USER.currentUser := 6;
		gvl_user.currentUserName :="Niezalogowany Użytkownik";
		gvl_user.currentUserGroup :='Niezalogowany';
		gvl_user.currentUserGroupNumber :=0; //
        GVL_USER.user_succesed_log := TRUE;  // Potwierdzenie, że wylogowanie i logowanie zakończyły się sukcesem
        GVL_USER.logout := FALSE;  // Resetowanie sygnału wylogowania
		GVL_USER.putted_user_password:='';
    END_IF
	GVL_USER.user_succesed_log := FALSE;
END_IF

//Proces nadpisania użytkowników w razie utraty Persistent
IF gvl_user.b_rewrite_users_after_issues OR bFirstCycle 
	THEN
	//admin
	gvl_user.user_array[1].userID:=0;
	gvl_user.user_array[1].enabled:=TRUE;
	gvl_user.user_array[1].userGroup:='Admin';
	gvl_user.user_array[1].userNameSurname:="Administrator";
	gvl_user.user_array[1].password:='adm';
	gvl_user.user_array[1].passwordRFID:='adm';
	gvl_user.user_array[1].passwordQR:='adm';
	gvl_user.user_array[1].userLogin:='adm';
	gvl_user.user_array[1].signedPassword:='adm';
	gvl_user.user_array[1].userGropuNumber:=1;
	//serwis
	gvl_user.user_array[3].userID:=2;
	gvl_user.user_array[3].enabled:=TRUE;
	gvl_user.user_array[3].userGroup:='Serwis';
	gvl_user.user_array[3].userNameSurname:="Serwisant";
	gvl_user.user_array[3].password:='ser';
	gvl_user.user_array[3].passwordRFID:='ser';
	gvl_user.user_array[3].passwordQR:='ser';
	gvl_user.user_array[3].userLogin:='ser';
	gvl_user.user_array[3].signedPassword:='ser';
	gvl_user.user_array[3].userGropuNumber:=4;
	//technolog
	gvl_user.user_array[4].userID:=3;
	gvl_user.user_array[4].enabled:=TRUE;
	gvl_user.user_array[4].userGroup:='Technolog';
	gvl_user.user_array[4].userNameSurname:="Technolog";
	gvl_user.user_array[4].password:='tech';
	gvl_user.user_array[4].passwordRFID:='tech';
	gvl_user.user_array[4].passwordQR:='tech';
	gvl_user.user_array[4].userLogin:='tech';	
	gvl_user.user_array[4].signedPassword:='tech';
	gvl_user.user_array[4].userGropuNumber:=5;
	//operator
	gvl_user.user_array[2].userID:=1;
	gvl_user.user_array[2].enabled:=TRUE;
	gvl_user.user_array[2].userGroup:='Operator';
	gvl_user.user_array[2].userNameSurname:="Operator";
	gvl_user.user_array[2].password:='opr';
	gvl_user.user_array[2].passwordRFID:='opr';
	gvl_user.user_array[2].passwordQR:='opr';
	gvl_user.user_array[2].userLogin:='opr';	
	gvl_user.user_array[2].signedPassword:='opr';
	gvl_user.user_array[2].userGropuNumber:=3;
	//mechanik
	gvl_user.user_array[5].userID:=4;
	gvl_user.user_array[5].enabled:=TRUE;
	gvl_user.user_array[5].userGroup:='Mechanik';
	gvl_user.user_array[5].userNameSurname:="Mechanik";
	gvl_user.user_array[5].password:='mech';
	gvl_user.user_array[5].passwordRFID:='mech';
	gvl_user.user_array[5].passwordQR:='mech';
	gvl_user.user_array[5].userLogin:='mech';	
	gvl_user.user_array[5].signedPassword:='mech';
	gvl_user.user_array[5].userGropuNumber:=2;
	
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>